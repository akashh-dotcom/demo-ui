#!/usr/bin/env python3
"""
Analyze ColId and ReadingOrderBlock Weaving on Single-Column Pages

This script analyzes pages where ColId alternates between 0 and 1,
which causes reading order issues on single-column pages with:
- Short headers
- Section headers
- Indented paragraphs
- Full-width paragraphs

Usage:
    python analyze_colid_weaving.py <excel_file.xlsx> [--page PAGE_NUM]
"""

import sys
import argparse
from openpyxl import load_workbook
from collections import defaultdict


def analyze_colid_patterns(excel_path, target_page=None):
    """
    Analyze ColId patterns from the ReadingOrder sheet.
    
    Args:
        excel_path: Path to Excel file generated by pdf_to_excel_columns.py
        target_page: Optional specific page number to analyze
    """
    print(f"\nLoading Excel file: {excel_path}")
    wb = load_workbook(excel_path, read_only=True)
    ws = wb["ReadingOrder"]
    
    # Skip header row
    rows = list(ws.iter_rows(min_row=2, values_only=True))
    
    # Group by page
    pages_data = defaultdict(list)
    for row in rows:
        page_num = row[0]  # Page
        stream_idx = row[1]  # StreamIndex
        reading_order = row[2]  # ReadingOrder
        reading_block = row[3]  # ReadingOrderBlock
        col_id = row[4]  # ColID
        row_index = row[5]  # RowIndex
        left = row[6]  # Left
        top = row[7]  # Top
        width = row[8]  # Width
        height = row[9]  # Height
        baseline = row[10]  # Baseline
        text = row[11]  # Text
        
        pages_data[page_num].append({
            "stream_idx": stream_idx,
            "reading_order": reading_order,
            "reading_block": reading_block,
            "col_id": col_id,
            "row_index": row_index,
            "left": left,
            "top": top,
            "width": width,
            "height": height,
            "baseline": baseline,
            "text": text,
        })
    
    print(f"Found {len(pages_data)} pages in Excel file\n")
    
    # Analyze each page (or just target page)
    pages_to_analyze = [target_page] if target_page else sorted(pages_data.keys())
    
    weaving_pages = []
    
    for page_num in pages_to_analyze:
        fragments = pages_data[page_num]
        if not fragments:
            continue
        
        # Sort by reading order
        fragments.sort(key=lambda f: f["reading_order"])
        
        # Calculate page width from fragments
        page_width = max(f["left"] + f["width"] for f in fragments)
        
        # Check for ColId weaving pattern
        col_id_sequence = [f["col_id"] for f in fragments]
        
        # Count transitions between ColId 0 and 1
        transitions = 0
        for i in range(1, len(col_id_sequence)):
            if col_id_sequence[i] != col_id_sequence[i-1] and \
               {col_id_sequence[i], col_id_sequence[i-1]} == {0, 1}:
                transitions += 1
        
        # Flag pages with excessive weaving (more than 3 transitions)
        has_weaving = transitions > 3
        
        if has_weaving:
            weaving_pages.append(page_num)
        
        # Print detailed analysis
        print(f"{'='*80}")
        print(f"PAGE {page_num} - ColId Transition Analysis")
        print(f"{'='*80}")
        print(f"Total fragments: {len(fragments)}")
        print(f"Page width: {page_width:.1f}")
        print(f"ColId transitions (0↔1): {transitions}")
        print(f"Weaving detected: {'YES' if has_weaving else 'NO'}")
        print(f"\nColId sequence: {col_id_sequence[:50]}{'...' if len(col_id_sequence) > 50 else ''}")
        
        # Count fragments by ColId
        col_id_counts = defaultdict(int)
        for f in fragments:
            col_id_counts[f["col_id"]] += 1
        
        print(f"\nFragments by ColId:")
        for col_id in sorted(col_id_counts.keys()):
            print(f"  ColId {col_id}: {col_id_counts[col_id]} fragments")
        
        # Identify unique reading blocks
        reading_blocks = sorted(set(f["reading_block"] for f in fragments))
        print(f"\nReading blocks: {reading_blocks}")
        
        # Analyze weaving patterns in detail
        if has_weaving or target_page == page_num:
            print(f"\n{'─'*80}")
            print("DETAILED COLID WEAVING ANALYSIS")
            print(f"{'─'*80}")
            print(f"{'RO':<5} {'Block':<7} {'ColID':<7} {'Left':<8} {'Width':<8} {'%Width':<8} {'Text':<45}")
            print(f"{'─'*80}")
            
            for i, f in enumerate(fragments[:100]):  # Show first 100 fragments
                text_preview = f["text"][:45] if f["text"] else ""
                text_preview = text_preview.replace("\n", " ")
                width_pct = (f["width"] / page_width) * 100
                
                # Highlight transitions
                marker = ""
                if i > 0:
                    prev_col_id = fragments[i-1]["col_id"]
                    if prev_col_id != f["col_id"] and {prev_col_id, f["col_id"]} == {0, 1}:
                        marker = " ← TRANSITION"
                
                print(f"{f['reading_order']:<5} {f['reading_block']:<7} {f['col_id']:<7} "
                      f"{f['left']:<8.1f} {f['width']:<8.1f} {width_pct:<7.1f}% "
                      f"{text_preview:<45}{marker}")
            
            if len(fragments) > 100:
                print(f"... ({len(fragments) - 100} more fragments)")
        
        print()
    
    # Summary
    if not target_page:
        print(f"{'='*80}")
        print("SUMMARY")
        print(f"{'='*80}")
        print(f"Pages with ColId weaving (>3 transitions): {len(weaving_pages)}")
        if weaving_pages:
            print(f"Affected pages: {weaving_pages[:20]}")
            if len(weaving_pages) > 20:
                print(f"... and {len(weaving_pages) - 20} more pages")


def analyze_colid_assignment_logic(excel_path, page_num):
    """
    Deep dive into why specific fragments got their ColId assignments.
    
    This analyzes the logic in assign_column_ids() to understand:
    - Which fragments are classified as full-width (ColId 0)
    - Which fragments are classified as column 1 (ColId 1)
    - Why the classification is happening
    """
    print(f"\n{'='*80}")
    print(f"COLID ASSIGNMENT LOGIC ANALYSIS - PAGE {page_num}")
    print(f"{'='*80}\n")
    
    wb = load_workbook(excel_path, read_only=True)
    ws = wb["ReadingOrder"]
    
    # Get fragments for target page
    fragments = []
    for row in ws.iter_rows(min_row=2, values_only=True):
        if row[0] == page_num:  # Page column
            fragments.append({
                "stream_idx": row[1],
                "reading_order": row[2],
                "reading_block": row[3],
                "col_id": row[4],
                "row_index": row[5],
                "left": row[6],
                "top": row[7],
                "width": row[8],
                "height": row[9],
                "baseline": row[10],
                "text": row[11],
            })
    
    if not fragments:
        print(f"No fragments found for page {page_num}")
        return
    
    # Calculate page dimensions
    page_width = max(f["left"] + f["width"] for f in fragments)
    
    # Thresholds from assign_column_ids()
    margin_ratio = 0.05
    left_margin = page_width * margin_ratio
    right_margin = page_width * (1.0 - margin_ratio)
    width_threshold = page_width * 0.45
    
    print(f"Page width: {page_width:.1f}")
    print(f"Left margin (<): {left_margin:.1f} ({margin_ratio*100:.0f}% of page)")
    print(f"Right margin (>): {right_margin:.1f} ({(1-margin_ratio)*100:.0f}% of page)")
    print(f"Width threshold: {width_threshold:.1f} ({0.45*100:.0f}% of page)")
    print()
    
    # Analyze each fragment
    print(f"{'RO':<5} {'ColID':<7} {'Left':<8} {'Right':<8} {'Width':<8} {'Reason':<30} {'Text':<35}")
    print(f"{'─'*110}")
    
    fragments.sort(key=lambda f: f["reading_order"])
    
    for f in fragments[:50]:  # Show first 50
        left = f["left"]
        right = left + f["width"]
        width = f["width"]
        text_preview = (f["text"][:35] if f["text"] else "").replace("\n", " ")
        
        # Determine assignment reason (mimics assign_column_ids logic)
        if left <= left_margin and right >= right_margin:
            reason = "Spans left→right margins"
            expected_col_id = 0
        elif width >= width_threshold:
            reason = f"Width ≥ {width_threshold:.0f} (45%)"
            expected_col_id = 0
        else:
            reason = "Narrow/indented → Column"
            expected_col_id = 1
        
        # Check if actual matches expected
        match_marker = "" if f["col_id"] == expected_col_id else " ⚠ UNEXPECTED"
        
        print(f"{f['reading_order']:<5} {f['col_id']:<7} "
              f"{left:<8.1f} {right:<8.1f} {width:<8.1f} "
              f"{reason:<30} {text_preview:<35}{match_marker}")
    
    if len(fragments) > 50:
        print(f"... ({len(fragments) - 50} more fragments)")


def main():
    parser = argparse.ArgumentParser(
        description="Analyze ColId weaving patterns in single-column pages",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("excel_path", help="Path to Excel file from pdf_to_excel_columns.py")
    parser.add_argument(
        "--page",
        type=int,
        help="Analyze specific page number"
    )
    parser.add_argument(
        "--logic",
        action="store_true",
        help="Show detailed ColId assignment logic analysis (requires --page)"
    )
    
    args = parser.parse_args()
    
    if args.logic and not args.page:
        print("Error: --logic requires --page to be specified")
        sys.exit(1)
    
    if args.logic:
        analyze_colid_assignment_logic(args.excel_path, args.page)
    else:
        analyze_colid_patterns(args.excel_path, args.page)


if __name__ == "__main__":
    main()
