"""
PDF Reference Mapping Wrapper

Wraps the existing PDF media extraction and flow building to integrate
with the reference mapping system.

This allows us to track all image/resource transformations during PDF
processing without modifying the existing complex logic.
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional
from lxml import etree

from reference_mapper import ReferenceMapper, get_mapper, reset_mapper

logger = logging.getLogger(__name__)


def register_pdf_media_with_mapper(media_xml_path: Path, mapper: ReferenceMapper) -> None:
    """
    Parse media.xml from PDF extraction and register all images in the reference mapper.

    Args:
        media_xml_path: Path to media.xml generated by media_extractor
        mapper: ReferenceMapper instance
    """
    if not media_xml_path.exists():
        logger.warning(f"Media XML not found: {media_xml_path}")
        return

    try:
        tree = etree.parse(str(media_xml_path))
        root = tree.getroot()

        for figure_elem in root.findall('.//figure'):
            # Extract metadata
            fig_type = figure_elem.get('type', 'unknown')
            filename = figure_elem.get('filename', '')
            page = figure_elem.get('page', '')
            chapter = figure_elem.get('chapter', '')
            section = figure_elem.get('section', '')

            if not filename:
                continue

            # Determine if vector or raster
            is_vector = (fig_type == 'vector')
            is_raster = (fig_type == 'raster')

            # Create a synthetic original path (since PDF doesn't have one)
            # We use the filename as both original and intermediate
            original_path = f"PDF_Page_{page}/{filename}"

            # Get caption if available
            caption_elem = figure_elem.find('caption')
            caption_text = caption_elem.text if caption_elem is not None and caption_elem.text else ""

            # Register in mapper
            mapper.add_resource(
                original_path=original_path,
                intermediate_name=filename,
                resource_type="image",
                first_seen_in=f"ch{chapter}",
                is_vector=is_vector,
                is_raster=is_raster,
            )

            logger.debug(f"Registered PDF image: {filename} (page {page}, chapter {chapter})")

        logger.info(f"Registered {len(root.findall('.//figure'))} images from media.xml")

    except Exception as e:
        logger.error(f"Failed to parse media.xml: {e}", exc_info=True)


def register_structured_xml_references(structured_xml_path: Path, mapper: ReferenceMapper) -> None:
    """
    Parse structured.xml and register all image references with their chapters.

    This tracks which chapters reference which images.

    Args:
        structured_xml_path: Path to structured.xml
        mapper: ReferenceMapper instance
    """
    if not structured_xml_path.exists():
        logger.warning(f"Structured XML not found: {structured_xml_path}")
        return

    try:
        parser = etree.XMLParser(resolve_entities=False, no_network=True)
        tree = etree.parse(str(structured_xml_path), parser)
        root = tree.getroot()

        # Find all chapters
        for chapter in root.findall('.//chapter'):
            chapter_id = chapter.get('id', 'unknown')

            # Find all imagedata elements in this chapter
            for imagedata in chapter.findall('.//imagedata'):
                fileref = imagedata.get('fileref', '')

                if fileref:
                    # Remove MultiMedia/ prefix if present
                    filename = fileref.replace('MultiMedia/', '')

                    # Try to find this resource in mapper by intermediate name
                    for original_path, ref in mapper.resources.items():
                        if ref.intermediate_name == filename:
                            mapper.add_reference(original_path, chapter_id)
                            logger.debug(f"Registered reference: {filename} in {chapter_id}")
                            break

        logger.info(f"Registered image references from structured.xml")

    except Exception as e:
        logger.error(f"Failed to parse structured.xml: {e}", exc_info=True)


def update_mapper_with_final_names(mapping_data: Dict[str, str], mapper: ReferenceMapper) -> None:
    """
    Update reference mapper with final names from package.py.

    Args:
        mapping_data: Dict of intermediate_name → final_name from packaging
        mapper: ReferenceMapper instance
    """
    for original_path, ref in mapper.resources.items():
        intermediate = ref.intermediate_name

        if intermediate in mapping_data:
            final_name = mapping_data[intermediate]
            mapper.update_final_name(original_path, final_name)
            logger.debug(f"Updated final name: {intermediate} → {final_name}")

    logger.info(f"Updated {len(mapping_data)} final names in mapper")


def count_resources(structured_xml_path: Path) -> Dict[str, int]:
    """
    Count resources in structured.xml for tracking purposes.

    Args:
        structured_xml_path: Path to structured.xml

    Returns:
        Dict with counts: num_chapters, num_images, num_tables, etc.
    """
    counts = {
        'num_chapters': 0,
        'num_images': 0,
        'num_tables': 0,
        'num_equations': 0,
        'num_sections': 0,
    }

    if not structured_xml_path.exists():
        return counts

    try:
        parser = etree.XMLParser(resolve_entities=False, no_network=True)
        tree = etree.parse(str(structured_xml_path), parser)
        root = tree.getroot()

        counts['num_chapters'] = len(root.findall('.//chapter'))
        counts['num_images'] = len(root.findall('.//imagedata'))
        counts['num_tables'] = len(root.findall('.//table'))
        counts['num_equations'] = len(root.findall('.//equation'))
        counts['num_sections'] = len(root.findall('.//section'))

    except Exception as e:
        logger.error(f"Failed to count resources: {e}")

    return counts


def detect_template_type(structured_xml_path: Path) -> str:
    """
    Detect if document is single-column, double-column, or mixed.

    This is a simple heuristic based on typical patterns.

    Args:
        structured_xml_path: Path to structured.xml

    Returns:
        Template type string: "Single Column", "Double Column", "Mixed", or "Unknown"
    """
    # For now, return Unknown - this could be enhanced with actual column detection
    # from the PDF layout analysis
    return "Unknown"


def integrate_pdf_with_mapper(media_xml_path: Path,
                              structured_xml_path: Path,
                              mapper: ReferenceMapper) -> None:
    """
    Full integration of PDF extraction results with reference mapper.

    Args:
        media_xml_path: Path to media.xml
        structured_xml_path: Path to structured.xml
        mapper: ReferenceMapper instance
    """
    logger.info("Integrating PDF extraction with reference mapper...")

    # Step 1: Register all extracted media
    register_pdf_media_with_mapper(media_xml_path, mapper)

    # Step 2: Register references in structured XML
    register_structured_xml_references(structured_xml_path, mapper)

    logger.info("PDF integration complete")
